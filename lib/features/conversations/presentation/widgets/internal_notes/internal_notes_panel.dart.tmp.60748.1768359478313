import 'package:flutter/material.dart';
import '../../../../../core/theme/viernes_colors.dart';
import '../../../../../core/theme/viernes_spacing.dart';
import '../../../../../core/theme/viernes_text_styles.dart';
import '../../../../../gen_l10n/app_localizations.dart';
import '../../../domain/entities/internal_note_entity.dart';
import 'internal_note_card.dart';

/// Panel mode enum for state management
enum NotePanelMode { list, compose, edit }

/// Internal Notes Panel
///
/// A bottom sheet panel for viewing and managing internal notes.
/// Uses transform animation pattern - single panel that morphs between
/// list and compose modes without opening additional modals.
///
/// IMPORTANT: This widget manages its own mode state (list/compose/edit).
/// When using with a ChangeNotifier provider, do NOT wrap this widget with
/// ListenableBuilder - it will reset the panel's internal state on every
/// provider notification. Instead, pass the provider via [notesProvider]
/// parameter and the panel will handle selective rebuilding internally.
class InternalNotesPanel extends StatefulWidget {
  final int conversationId;
  final int? currentUserId;

  /// The notes provider - if provided, the panel will listen to changes
  /// internally and only rebuild the list content (not the whole panel).
  final ChangeNotifier? notesProvider;

  /// Callback to get notes from provider
  final List<InternalNoteEntity> Function()? getNotesFromProvider;

  /// Callback to check loading state
  final bool Function()? isProviderLoading;

  /// Callback to check if has more
  final bool Function()? providerHasMore;

  /// Callback to get error message
  final String? Function()? getProviderError;

  // Direct data (used when not using provider pattern)
  final List<InternalNoteEntity> notes;
  final bool isLoading;
  final bool hasMore;
  final String? errorMessage;

  final Future<void> Function()? onLoadMore;
  final Future<void> Function()? onRefresh;
  final Future<bool> Function(String content)? onCreateNote;
  final Future<bool> Function(int noteId, String content)? onUpdateNote;
  final Future<bool> Function(int noteId)? onDeleteNote;

  const InternalNotesPanel({
    super.key,
    required this.conversationId,
    this.currentUserId,
    this.notesProvider,
    this.getNotesFromProvider,
    this.isProviderLoading,
    this.providerHasMore,
    this.getProviderError,
    this.notes = const [],
    this.isLoading = false,
    this.hasMore = false,
    this.errorMessage,
    this.onLoadMore,
    this.onRefresh,
    this.onCreateNote,
    this.onUpdateNote,
    this.onDeleteNote,
  });

  /// Show the panel as a bottom sheet
  static Future<void> show({
    required BuildContext context,
    required int conversationId,
    required List<InternalNoteEntity> notes,
    bool isLoading = false,
    bool hasMore = false,
    String? errorMessage,
    int? currentUserId,
    Future<void> Function()? onLoadMore,
    Future<void> Function()? onRefresh,
    Future<bool> Function(String content)? onCreateNote,
    Future<bool> Function(int noteId, String content)? onUpdateNote,
    Future<bool> Function(int noteId)? onDeleteNote,
  }) {
    return showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (_) => DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (_, scrollController) => InternalNotesPanel(
          conversationId: conversationId,
          notes: notes,
          isLoading: isLoading,
          hasMore: hasMore,
          errorMessage: errorMessage,
          currentUserId: currentUserId,
          onLoadMore: onLoadMore,
          onRefresh: onRefresh,
          onCreateNote: onCreateNote,
          onUpdateNote: onUpdateNote,
          onDeleteNote: onDeleteNote,
        ),
      ),
    );
  }

  @override
  State<InternalNotesPanel> createState() => _InternalNotesPanelState();
}

class _InternalNotesPanelState extends State<InternalNotesPanel> {
  final ScrollController _scrollController = ScrollController();
  final TextEditingController _composerController = TextEditingController();
  final FocusNode _composerFocusNode = FocusNode();

  NotePanelMode _mode = NotePanelMode.list;
  InternalNoteEntity? _editingNote;
  bool _isSaving = false;

  // For undo delete functionality
  InternalNoteEntity? _deletedNote;

  static const int _maxCharacters = 1000;
  static const int _minCharacters = 3;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _composerController.dispose();
    _composerFocusNode.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
            _scrollController.position.maxScrollExtent - 200 &&
        widget.hasMore &&
        !widget.isLoading) {
      widget.onLoadMore?.call();
    }
  }

  /// Enter compose mode for creating a new note
  void _enterComposeMode() {
    setState(() {
      _mode = NotePanelMode.compose;
      _editingNote = null;
      _composerController.clear();
    });
    // Auto-focus after frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _composerFocusNode.requestFocus();
    });
  }

  /// Enter edit mode for an existing note
  void _enterEditMode(InternalNoteEntity note) {
    setState(() {
      _mode = NotePanelMode.edit;
      _editingNote = note;
      _composerController.text = note.content;
    });
    // Auto-focus after frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _composerFocusNode.requestFocus();
    });
  }

  /// Exit compose/edit mode and return to list
  void _exitComposeMode() {
    setState(() {
      _mode = NotePanelMode.list;
      _editingNote = null;
      _composerController.clear();
    });
  }

  /// Handle saving (create or update)
  Future<void> _handleSave() async {
    final content = _composerController.text.trim();
    if (content.length < _minCharacters) return;

    final l10n = AppLocalizations.of(context);
    setState(() => _isSaving = true);

    try {
      bool success = false;

      if (_mode == NotePanelMode.edit && _editingNote != null) {
        // Update existing note
        if (widget.onUpdateNote != null) {
          success = await widget.onUpdateNote!(_editingNote!.id, content);
        }
      } else {
        // Create new note
        if (widget.onCreateNote != null) {
          success = await widget.onCreateNote!(content);
        }
      }

      if (mounted) {
        if (success) {
          _exitComposeMode();
        } else {
          final errorMsg = _mode == NotePanelMode.edit
              ? (l10n?.errorUpdateNote ?? 'Error updating note')
              : (l10n?.errorCreateNote ?? 'Error creating note');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(errorMsg),
              backgroundColor: ViernesColors.danger,
            ),
          );
        }
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  /// Handle delete with Snackbar + Undo (no confirmation dialog)
  Future<void> _handleDeleteNote(InternalNoteEntity note) async {
    final l10n = AppLocalizations.of(context);

    // Store for potential undo
    _deletedNote = note;

    // Optimistically remove from UI (parent widget handles actual list)
    if (widget.onDeleteNote != null) {
      final success = await widget.onDeleteNote!(note.id);

      if (mounted) {
        if (success) {
          // Show snackbar with undo option
          ScaffoldMessenger.of(context).clearSnackBars();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(l10n?.noteDeleted ?? 'Note deleted'),
              action: SnackBarAction(
                label: l10n?.undo ?? 'Undo',
                onPressed: _handleUndoDelete,
              ),
              duration: const Duration(seconds: 5),
            ),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(l10n?.errorDeleteNote ?? 'Error deleting note'),
              backgroundColor: ViernesColors.danger,
            ),
          );
        }
      }
    }
  }

  /// Undo the delete action
  Future<void> _handleUndoDelete() async {
    if (_deletedNote == null || widget.onCreateNote == null) return;

    // Re-create the note with the same content
    await widget.onCreateNote!(_deletedNote!.content);
    _deletedNote = null;
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;

    return Container(
      decoration: BoxDecoration(
        color: ViernesColors.getControlBackground(isDark),
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: SafeArea(
        child: Column(
          children: [
            // Handle bar
            Container(
              margin: const EdgeInsets.only(top: ViernesSpacing.sm),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: ViernesColors.getTextColor(isDark).withValues(alpha: 0.2),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            // Header (animated between modes)
            _buildHeader(isDark),
            const Divider(height: 1),
            // Content (animated between modes)
            Expanded(
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 250),
                switchInCurve: Curves.easeInOut,
                switchOutCurve: Curves.easeInOut,
                transitionBuilder: (child, animation) {
                  return FadeTransition(
                    opacity: animation,
                    child: SlideTransition(
                      position: Tween<Offset>(
                        begin: const Offset(0.05, 0),
                        end: Offset.zero,
                      ).animate(animation),
                      child: child,
                    ),
                  );
                },
                child: _mode == NotePanelMode.list
                    ? _buildListContent(isDark)
                    : _buildComposeContent(isDark),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Build header based on current mode
  Widget _buildHeader(bool isDark) {
    final l10n = AppLocalizations.of(context);

    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 200),
      child: _mode == NotePanelMode.list
          ? _buildListHeader(isDark, l10n)
          : _buildComposeHeader(isDark, l10n),
    );
  }

  /// Header for list mode
  Widget _buildListHeader(bool isDark, AppLocalizations? l10n) {
    return Padding(
      key: const ValueKey('list_header'),
      padding: const EdgeInsets.all(ViernesSpacing.md),
      child: Row(
        children: [
          const Icon(
            Icons.note_alt_outlined,
            color: ViernesColors.primary,
            size: 24,
          ),
          const SizedBox(width: ViernesSpacing.sm),
          Expanded(
            child: Text(
              l10n?.internalNotesTitle ?? 'Internal notes',
              style: ViernesTextStyles.h6.copyWith(
                color: ViernesColors.getTextColor(isDark),
              ),
            ),
          ),
          // Add button
          IconButton(
            onPressed: _enterComposeMode,
            icon: const Icon(
              Icons.add_circle_outline,
              color: ViernesColors.primary,
            ),
            tooltip: l10n?.addNoteTooltip ?? 'Add note',
          ),
        ],
      ),
    );
  }

  /// Header for compose/edit mode
  Widget _buildComposeHeader(bool isDark, AppLocalizations? l10n) {
    final isEditing = _mode == NotePanelMode.edit;
    final title = isEditing
        ? (l10n?.editInternalNote ?? 'Edit Note')
        : (l10n?.newInternalNote ?? 'New Note');

    final canSave = _composerController.text.trim().length >= _minCharacters &&
        !_isSaving;

    return Padding(
      key: const ValueKey('compose_header'),
      padding: const EdgeInsets.symmetric(
        horizontal: ViernesSpacing.sm,
        vertical: ViernesSpacing.xs,
      ),
      child: Row(
        children: [
          // Back button
          IconButton(
            onPressed: _isSaving ? null : _exitComposeMode,
            icon: Icon(
              Icons.arrow_back,
              color: ViernesColors.getTextColor(isDark),
            ),
            tooltip: l10n?.back ?? 'Back',
          ),
          // Title
          Expanded(
            child: Text(
              title,
              style: ViernesTextStyles.h6.copyWith(
                color: ViernesColors.getTextColor(isDark),
              ),
            ),
          ),
          // Save button
          TextButton(
            onPressed: canSave ? _handleSave : null,
            child: _isSaving
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text(
                    l10n?.save ?? 'Save',
                    style: TextStyle(
                      color: canSave
                          ? ViernesColors.primary
                          : ViernesColors.getTextColor(isDark)
                              .withValues(alpha: 0.4),
                      fontWeight: FontWeight.w600,
                    ),
                  ),
          ),
        ],
      ),
    );
  }

  /// Build compose/edit content
  Widget _buildComposeContent(bool isDark) {
    final l10n = AppLocalizations.of(context);
    final charCount = _composerController.text.length;
    final isOverLimit = charCount > _maxCharacters;

    return Container(
      key: const ValueKey('compose_content'),
      padding: const EdgeInsets.all(ViernesSpacing.md),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Helper text
          Container(
            padding: const EdgeInsets.all(ViernesSpacing.sm),
            decoration: BoxDecoration(
              color: ViernesColors.warning.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: ViernesColors.warning.withValues(alpha: 0.3),
              ),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.visibility_off_outlined,
                  size: 16,
                  color: ViernesColors.warning,
                ),
                const SizedBox(width: ViernesSpacing.sm),
                Expanded(
                  child: Text(
                    l10n?.noteVisibleToAgents ??
                        'This note will only be visible to agents',
                    style: ViernesTextStyles.bodySmall.copyWith(
                      color: ViernesColors.getTextColor(isDark)
                          .withValues(alpha: 0.8),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: ViernesSpacing.md),
          // Text field
          Expanded(
            child: TextField(
              controller: _composerController,
              focusNode: _composerFocusNode,
              maxLines: null,
              expands: true,
              textAlignVertical: TextAlignVertical.top,
              maxLength: _maxCharacters,
              buildCounter: (context,
                  {required currentLength, required isFocused, maxLength}) {
                return null; // We'll show our own counter
              },
              onChanged: (_) => setState(() {}),
              decoration: InputDecoration(
                hintText: l10n?.writeNoteHint ?? 'Write your note here...',
                hintStyle: ViernesTextStyles.bodyText.copyWith(
                  color: ViernesColors.getTextColor(isDark).withValues(alpha: 0.4),
                ),
                filled: true,
                fillColor: isDark
                    ? ViernesColors.getControlBackground(isDark)
                        .withValues(alpha: 0.5)
                    : Colors.grey.shade100,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(
                    color: ViernesColors.getBorderColor(isDark),
                  ),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(
                    color: ViernesColors.getBorderColor(isDark),
                  ),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: const BorderSide(
                    color: ViernesColors.primary,
                    width: 2,
                  ),
                ),
                contentPadding: const EdgeInsets.all(ViernesSpacing.md),
              ),
              style: ViernesTextStyles.bodyText.copyWith(
                color: ViernesColors.getTextColor(isDark),
              ),
            ),
          ),
          const SizedBox(height: ViernesSpacing.sm),
          // Character counter
          Align(
            alignment: Alignment.centerRight,
            child: Text(
              '$charCount / $_maxCharacters',
              style: ViernesTextStyles.caption.copyWith(
                color: isOverLimit
                    ? ViernesColors.danger
                    : ViernesColors.getTextColor(isDark).withValues(alpha: 0.5),
                fontWeight: isOverLimit ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Get current notes (from provider or direct prop)
  List<InternalNoteEntity> _getNotes() {
    if (widget.notesProvider != null && widget.getNotesFromProvider != null) {
      return widget.getNotesFromProvider!();
    }
    return widget.notes;
  }

  /// Get loading state (from provider or direct prop)
  bool _getIsLoading() {
    if (widget.notesProvider != null && widget.isProviderLoading != null) {
      return widget.isProviderLoading!();
    }
    return widget.isLoading;
  }

  /// Get has more (from provider or direct prop)
  bool _getHasMore() {
    if (widget.notesProvider != null && widget.providerHasMore != null) {
      return widget.providerHasMore!();
    }
    return widget.hasMore;
  }

  /// Get error message (from provider or direct prop)
  String? _getErrorMessage() {
    if (widget.notesProvider != null && widget.getProviderError != null) {
      return widget.getProviderError!();
    }
    return widget.errorMessage;
  }

  /// Build list content - wraps with ListenableBuilder if provider is available
  Widget _buildListContent(bool isDark) {
    if (widget.notesProvider != null) {
      return ListenableBuilder(
        listenable: widget.notesProvider!,
        builder: (_, __) => _buildListContentInner(isDark),
      );
    }
    return _buildListContentInner(isDark);
  }

  /// Inner list content builder
  Widget _buildListContentInner(bool isDark) {
    final l10n = AppLocalizations.of(context);
    final notes = _getNotes();
    final isLoading = _getIsLoading();
    final hasMore = _getHasMore();
    final errorMessage = _getErrorMessage();

    // Error state
    if (errorMessage != null && notes.isEmpty) {
      return Center(
        key: const ValueKey('error_content'),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 48,
              color: ViernesColors.danger.withValues(alpha: 0.5),
            ),
            const SizedBox(height: ViernesSpacing.md),
            Text(
              errorMessage!,
              style: ViernesTextStyles.bodyText.copyWith(
                color: ViernesColors.getTextColor(isDark).withValues(alpha: 0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: ViernesSpacing.md),
            TextButton(
              onPressed: widget.onRefresh,
              child: Text(l10n?.retry ?? 'Retry'),
            ),
          ],
        ),
      );
    }

    // Loading state (initial)
    if (isLoading && notes.isEmpty) {
      return const Center(
        key: ValueKey('loading_content'),
        child: CircularProgressIndicator(),
      );
    }

    // Empty state
    if (notes.isEmpty) {
      return Center(
        key: const ValueKey('empty_content'),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.note_alt_outlined,
              size: 64,
              color: ViernesColors.getTextColor(isDark).withValues(alpha: 0.3),
            ),
            const SizedBox(height: ViernesSpacing.md),
            Text(
              l10n?.noInternalNotesTitle ?? 'No internal notes',
              style: ViernesTextStyles.h6.copyWith(
                color: ViernesColors.getTextColor(isDark),
              ),
            ),
            const SizedBox(height: ViernesSpacing.sm),
            Text(
              l10n?.internalNotesAgentsOnly ??
                  'Internal notes are only visible to agents',
              style: ViernesTextStyles.bodySmall.copyWith(
                color: ViernesColors.getTextColor(isDark).withValues(alpha: 0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: ViernesSpacing.lg),
            ElevatedButton.icon(
              onPressed: _enterComposeMode,
              icon: const Icon(Icons.add, size: 18),
              label: Text(l10n?.addNoteButton ?? 'Add note'),
              style: ElevatedButton.styleFrom(
                backgroundColor: ViernesColors.primary,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(
                  horizontal: ViernesSpacing.lg,
                  vertical: ViernesSpacing.sm,
                ),
                minimumSize: Size.zero,
                tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              ),
            ),
          ],
        ),
      );
    }

    // Notes list
    return RefreshIndicator(
      key: const ValueKey('list_content'),
      onRefresh: () async {
        await widget.onRefresh?.call();
      },
      child: ListView.builder(
        controller: _scrollController,
        padding: const EdgeInsets.all(ViernesSpacing.md),
        itemCount: notes.length + (isLoading ? 1 : 0),
        itemBuilder: (context, index) {
          if (index >= notes.length) {
            return const Padding(
              padding: EdgeInsets.all(ViernesSpacing.md),
              child: Center(child: CircularProgressIndicator()),
            );
          }

          final note = notes[index];
          final canEdit = widget.currentUserId == note.agentId;

          return Padding(
            padding: const EdgeInsets.only(bottom: ViernesSpacing.sm),
            child: InternalNoteCard(
              note: note,
              canEdit: canEdit,
              onEdit: () => _enterEditMode(note),
              onDelete: () => _handleDeleteNote(note),
            ),
          );
        },
      ),
    );
  }
}
